"""
    Template Compositor
    ~~~~~~~~~~~~~~~~~~~
    
    A wrapper around various templating engines
    (currently only Jinja2, more planned soon) to
    make it easier to take advantage of templating
    outside of an application server.  Also helpful
    for dynamically generating HTML periodically
    (instead of on every call) for improving app 
    server response times without sacrificing 
    dynamic HTML composition.
    
    Creative uses:
    - Statically render your HTML templates to HTML
      files and remove all that overhead from your 
      app server!
    - Templates for anything! Email! Shopping lists!
      Other things I can't think of!
      
    Configuration file format::
    ~~~~~~~~~~~~~~~~~~~~~~~~~~
        The configuration file must be formatted as a JSON
        list of maps/dictionaries.  Each map/dictionary 
        represents a single file to create based on a set of
        templates and has 3 required keys:
        
        `source_filename`:  String.
            The filename of the "root" template file. This
            file is the initial file passed to the templating
            engine.  Any additional files that are required
            should be appropriately referenced within this file
            in order to be included.  See the docs for the 
            templating engine you are using for more details.
            
        `context`:  Map/Dictionary.
            This map contains all of the "dynamic" values to
            be used when the templating engine is building 
            the output file.  If no the templates contain no
            variables, this should just be an empty map.

        `output_filename`:  String.
            The filename of the output file that is to be
            generated by :class:`Compositor`.  This path is
            assumed to be relative to the directory in which
            compositor is run.
        
        See `example.compositor.config` for a simple example.
"""


import json
from os import makedirs
from os.path import join, exists, dirname, abspath
from jinja2 import Environment, FileSystemLoader 

class Compositor(object):
    """
    Primary Compositor class.  Takes configuration values and
    compiles together specified templates using the specified
    templating engine (currently only Jinja2).
    
    To use this class apart from the main compositor application,
    create an instance of this class and call the :meth:`compile` method.
    
    Most common uses::
    
    * From current directory (with default config file)::
        from compositor import Compositor
        comp = Compositor(".")
        comp.compile()
    
    * From current directory (with custom config file)::
        from compositor import Compositor
        comp = Compositor(".", "/location/of/custom/config/file.config")
        comp.compile()
        
    * In non-current directory (with default config file)::
        from compositor import Compositor
        comp = Compositor("/root/of/template/files")
        comp.compile()
        
        
    :param template_root: Required.  The root of the directory tree which
                          holds all of the files referenced in the 
                          configuration file.  All files in the configuration
                          file or within a template file are assumed to be
                          relative to this directory.
                          
    :param config_file:  Optional.  Specify a configuration
                         file that either has a different name from the
                         default (compositor.config) or exists in a 
                         different location (not in template_root). Defaults
                         to os.path.join(template_root, "compositor.config").
                         This is passed directly to :class:`file` and can be
                         any format that the :class:`file` class understands
                         (can be either relative or absolute).
    """
    
    # Default configuration filename
    CONFIG_FILE = "compositor.config"
    
    def __init__(self, template_root, config_file=None):
        # Setup Jinja2 environment
        self._env = Environment(loader=FileSystemLoader(template_root))
        # Select between user-specific config file and default
        if config_file is not None:
            self._config = config_file
        else:
            self._config = join(template_root, Compositor.CONFIG_FILE)
        # Load config
        try:
            self._load_config()
        except IOError as e:
            print "Error! Unable to load configuration! %s" % e
                    
        
    def compile(self):
        """
        Compile together each of the templates described by this
        Compositor's configuration file.
        Loop over each of the template description blocks and create a 
        static file from the provided files and context values.
        This method will do nothing if no valid configuration file was loaded.
        """
        if self._outputs is None or len(self._outputs) == 0:
            print "Error! No templates to compile! Did you specify a valid configuration file?"
        else:
            # for each output file in output list 
            for output in self._outputs:
                # Generate context
                context = output["context"]
                # Generate template stream for that output
                tmpl = self._env.get_template(output["source_filename"]).stream(context)
                # Verify output directory
                output_filename = output["output_filename"]
                output_path = abspath(dirname(output_filename))
                if not exists(output_path):
                    makedirs(output_path)
                # Render it to the output file
                tmpl.dump(output_filename)
                
                
    #Private method
    def _load_config(self):
        self._outputs = []
        # If they specified a config file
        if self._config is not None:
            with file(self._config) as config_file:
                # Try to load file as JSON data
                config = json.load(config_file)
                # If it was valid JSON
                if config is not None and isinstance(config, list):
                    self._outputs = config
                else:
                    print "Could not load config file or was not a list of objects: %s" % self._config
        else:
            print "Error! No configuration file specified!"